<!doctype html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lambda Calculus Evaluator</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=JetBrains+Mono:wght@300..800&display=swap"
      rel="stylesheet"
    />

    <!-- Pico CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.1.1/css/pico.min.css"
    />

    <!-- Custom theme (must come AFTER Pico) -->
    <link rel="stylesheet" href="/static/styles.css?v=2" />
  </head>

  <body>
    <main class="container">
      <header class="page-header">
        <h1>Evaluate untyped λ-calculus</h1>
        <p class="subtitle">
          Choose a β‑reduction strategy, evaluate, and inspect the reduction
          steps.
        </p>
      </header>

      <section class="info-accordion" aria-label="About and help">
        <details>
          <summary>How to use</summary>
          <p>Write a program with the following format:</p>
          <ul>
            <li><strong>any</strong> let bindings</li>
            <li><strong>one</strong> final expression to be evaluated</li>
          </ul>
          <p>
            Then choose a beta-reduction strategy, optionally enable logging of
            beta reduction steps, and evaluate.
          </p>
          <blockquote>
            <p>
              To understand more about the beta-reduction strategies, see the
              "About λ-Calculus" section.
            </p>
          </blockquote>
          <p>
            A
            <a
              href="https://github.com/PedrobyJoao/untyped-lambda-evaluator/blob/main/static/prelude.lam"
              >prelude</a
            >
            with a few useful definitions (combinators, church numbers, etc) can
            be included.
          </p>
          <p>
            When the prelude is included, user's definitions can overwritte
            prelude's when they share the same name.
          </p>
          <p>
            Now, regarding lambda syntax: the lambda symbol can be written as
            either <code>\</code> or <code>λ</code> as in <code>λx.x</code> or
            <code>λx.x</code>
          </p>
          <h5>Equational referencing</h5>
          <p>
            As already mentioned, it includes equational referencing, so instead
            of writing one big lambda expression, expressions can be "assigned"
            to names (as <code>let id = λx.x</code>) and reused anywhere.
          </p>
          <p>
            Before evaluation, references will be replaced by their pure lambda
            expression representation.
          </p>
          <blockquote>
            <p>
              PS: let definitions can <em>not</em> be recursive.<br />
              Thus <code>let f = λx. f x</code> is not allowed.
            </p>
          </blockquote>
          <p>
            <em>
              After evaluation, we also replace the final expression with a
              loaded reference if any is alpha-equivalent </em
            >.
          </p>
          <blockquote>
            <p>
              Possible confusion point: if prelude is included, the resultant
              expression can be something unexpected: a term defined in the
              prelude (such as <code>zero</code> which is <code>λf.λx.x</code>).
            </p>
          </blockquote>
          <h4>Final notes</h4>
          <ul>
            <li>Limited to 2^12 beta-reduction steps</li>
            <li>
              Call-by-value (Weak, Strict) and Call-by-need (Weak, Lazy) to be
              implemented yet.
            </li>
            <li>It does not feature eta-reductions.</li>
            <li>
              It's not possible to indent code. Use multiple lines for big
              expressions or simplify with more let bindings.
            </li>
          </ul>
        </details>
        <details>
          <summary>About λ-calculus</summary>
          <p>
            Lambda calculus is a formal system for representing computation
            created by Alonzo Church in 1930s. If you think as a programming
            language, it's turing complete.
          </p>
          <p>
            As a rewriting system, untyped lambda calculus is not strongly
            normalizing. Meaning that there are terms with no normal form such
            as: <code>(λx.x x) (λx.x x)</code>
          </p>
          <p>
            Lambda calculus builds terms from three pieces: variables,
            abstractions, and applications.
          </p>
          <p>A <strong>variable</strong> is a name like <code>x</code>.</p>
          <p>
            An <strong>abstraction</strong> <code>λx. t</code> is an anonymous
            function that binds <code>x</code> in the body <code>t</code>.
          </p>
          <p>
            And <strong>application</strong> <code>t s</code> means "apply
            <code>t</code> to <code>s</code>" (left-associative, so
            <code>f a b</code> means <code>(f a) b</code>).
          </p>
          <h4>β-reduction</h4>
          <p>
            A <em>redex (reducible expression)</em> is any application where the
            left side is an abstraction: <code>(λx. t) s</code>.
          </p>
          <p>
            Now, <strong>β-reduction</strong> is the substitution step upon a
            redex: <code>(λx. t) s -&gt; t[x := s]</code>
          </p>
          <p>
            <code>t[x := s]</code> means: replace all occurrences of
            <code>s</code> for the free occurrences of <code>x</code> in
            <code>t</code>.
          </p>
          <blockquote>
            <p>
              Free occurence refers to a variable that is not bound to any
              previous abstraction.<br /><br />
              The replacement process includes something called capture-avoiding
              substitution. You may check out more about it in the "Learn more
              here" section's links.
            </p>
          </blockquote>
          <p>Example:</p>
          <pre><code class="language-hs">(λx. x y) z -- a redex
-- one β-reduction
z y -- an application between two free variables
</code></pre>
          <h4>Normal Form</h4>
          <p>
            A term is in normal form when no beta-reduction applies, i.e. it has
            no subexpression of the form <code>(λx. t) s</code>, meaning it has
            no redexes.
          </p>
          <p>
            For example, <code>(λx. x) y -&gt; y</code>, and <code>y</code> is
            in normal form.
          </p>
          <h4>Weak Head Normal Form (WHNF)</h4>
          <p>
            A term is in WHNF when its <em>head is not a beta-redex</em>.
            Redexes may still appear inside arguments or inside lambda bodies.
          </p>
          <blockquote>
            <p>
              Head: the leftmost term in a left-associative application
              chain.<br />
              Example: <code>f a b</code> means <code>((f a) b)</code>, so the
              head is <code>f</code>.
            </p>
          </blockquote>
          <pre><code class="language-hs">-- WHNF:
λx. (λy. y) x
f ((λx. x) y)
x y z

-- Not WHNF (head redex):
(λx. x) y
((λx. x) y)
((λx. x) y) z
</code></pre>
          <h4>Reduction strategies</h4>
          <p>
            Reduction strategies differ in how they choose which redex to reduce
            first.
          </p>
          <p>They can be <em>strong</em> or <em>weak</em>.</p>
          <p>
            <em>Strong</em>: it reduces under lambdas. It can reach normal form
            if it terminates.
          </p>
          <p>
            <em>Weak</em>: it does NOT reduce under lambdas. It's still possible
            to find the normal form if the expression doesn't require reducing
            under lambdas). Otherwise, the last weak reduction results in the
            Weak Head Normal Form (WHNF) of the expression
          </p>
          <p>
            A few reduction strategies are: Normal Order, Applicative,
            Call-by-name, and Call-by-value.
          </p>
          <blockquote>
            <p>
              Note: beta‑reduction is confluent (Church–Rosser), so if a term
              has a normal form, it is unique.<br />
              Any strategy that terminates reaches the same normal form.
            </p>
          </blockquote>
          <h5>Normal Order (Strong, Non-Strict):</h5>
          <p>It reduces first the <em>leftmost outermost</em> redex.</p>
          <p>
            Arguments are substituted into the abstraction body before being
            reduced.
          </p>
          <pre><code class="language-hs">let f = λa. a b c
let arg = (λx.x) y -- not in normal form, it can be reduced

f arg

-- ONE beta-reduction step outputs:

arg b c
-- or
((λx.x) y) b c
</code></pre>
          <p>
            Normal Order reduction is normalizing, meaning it's guaranteed to
            reduce until normal form if one exists.
          </p>
          <h5>Applicative (Strong, Strict):</h5>
          <p>It reduces first the <em>leftmost innermost</em> redex.</p>
          <p>Arguments are reduced first, and then substituted.</p>
          <pre><code class="language-hs">let f = λa. a b c
let arg = (λx.x) y -- not in normal form, it can be reduced

f arg

-- ONE beta-reduction step outputs:

f y
-- or
(λa. a b c) y
</code></pre>
          <h6>Applicative is not normalizing</h6>
          <p>
            Applicative does not guarantee reduction until normal form even if
            one exists.
          </p>
          <pre><code class="language-hs">let const = λx. λy. x
let omega = (λx. x x) (λx. x x)

const ok omega
</code></pre>
          <p>
            Normal order fully normalizes the expression as it does not try to
            reduce omega.
          </p>
          <p>
            Applicative does not terminate because it tries to reduce omega
            first, getting stuck in infinite recursion.
          </p>
          <h5>
            Call-by-name (Weak, non-strict but it may recompute reductions)
          </h5>
          <p>
            It reduces only the leftmost outermost expression until it's a
            lambda, and then it applies the arguments without reducing them.
          </p>
          <pre><code class="language-hs">let const = λx. λy. x
let arg = (λz. z) w

const arg

-- ONE beta-reduction step outputs:

λy. arg
-- or
λy. ((λz. z) w)

-- This stops at WHNF (a lambda), even though the body still has a redex.
-- Thus, for Call-by-Name, there are no more reductions be applied.
</code></pre>
          <h5>Call-by-value (Weak, strict)</h5>
          <p>
            It reduces the leftmost outermost redex only after first reducing
            the argument to a value. It does NOT reduce under lambdas as
            Call-by-Name.
          </p>
          <pre><code class="language-hs">let f = λx. λy. (λz. z) y
let arg = (λu. u) (λv. v)

f arg

-- one step: call-by-value reduces the argument first
(λx. λy. (λz. z) y) (λv. v) -- or f (λv.v)
-- one step: then applies
λy. (λz. z) y -- WHNF
-- stops at WHNF (lambda head), even though the body still has a redex.
</code></pre>
          <h4>Learn more here:</h4>
          <ul>
            <li>
              <a href="https://serokell.io/blog/untyped-lambda-calculus"
                >https://serokell.io/blog/untyped-lambda-calculus</a
              >
            </li>
            <li>
              <a href="https://en.wikipedia.org/wiki/Lambda_calculus"
                >https://en.wikipedia.org/wiki/Lambda_calculus</a
              >
            </li>
            <li>
              <a
                href="https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf"
                >https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf</a
              >
            </li>
            <li>
              <a
                href="https://www.cs.bu.edu/fac/snyder/cs320/Lectures/Lecture15--%20Lambda%20Calculus%20II.pdf"
                >https://www.cs.bu.edu/fac/snyder/cs320/Lectures/Lecture15--%20Lambda%20Calculus%20II.pdf</a
              >
            </li>
            <li>
              <a
                href="https://opendsa.cs.vt.edu/ODSA/Books/PL/html/ReductionStrategies.html"
                >https://opendsa.cs.vt.edu/ODSA/Books/PL/html/ReductionStrategies.html</a
              >
            </li>
            <li>
              <a href="https://j-hui.com/pages/normal-forms/"
                >https://j-hui.com/pages/normal-forms/</a
              >
            </li>
          </ul>
        </details>
      </section>

      <article class="panel">
        <form
          hx-post="/eval"
          hx-target="#results"
          hx-swap="innerHTML"
          hx-disabled-elt="#evalButton"
        >
          <label>
            <input type="checkbox" name="withPrelude" />
            <span>
              Include Prelude (<a
                href="https://github.com/PedrobyJoao/untyped-lambda-evaluator/blob/main/static/prelude.lam"
                >source code</a
              >)
            </span>
          </label>

          <label for="expr" class="sr-only">Expression</label>
          <textarea id="expr" name="expr" rows="10" required>
-- Program format:
-- 1) zero or more let bindings (definitions)
-- 2) a final expression to be evaluated (the last non-comment line)

-- Church numerals
let one = \f.\x. f x
let two = \f.\x. f (f x)
let three = \f.\x. f (f (f x))

let add = \m.\n.\f.\x. m f (n f x)

-- expression to be evaluated (1 + 2)
add one two
          </textarea>

          <fieldset>
            <legend>Reduction strategy:</legend>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="normal" checked />
                <span>Normal order</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="applicative" />
                <span>Applicative order</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="cbn" />
                <span>Call-by-name (WHNF)</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="cbv" />
                <span>Call-by-Value (WHNF)</span>
              </label>
            </div>
          </fieldset>

          <label>
            <input type="checkbox" name="showSteps" />
            <span>Show β-Reduction steps</span>
          </label>

          <button id="evalButton" type="submit">Evaluate</button>
        </form>
      </article>

      <!-- Hidden by default by being empty; populated after /eval -->
      <div id="results"></div>
    </main>

    <script src="https://unpkg.com/htmx.org@2.0.7"></script>
  </body>
</html>
