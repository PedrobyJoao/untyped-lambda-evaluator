<!doctype html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lambda Calculus Evaluator</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=JetBrains+Mono:wght@300..800&display=swap"
      rel="stylesheet"
    />

    <!-- Pico CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.1.1/css/pico.min.css"
    />

    <!-- Custom theme (must come AFTER Pico) -->
    <link rel="stylesheet" href="/static/styles.css?v=2" />
  </head>

  <body>
    <main class="container">
      <header class="page-header">
        <h1>Evaluate untyped λ-calculus</h1>
        <p class="subtitle">
          Choose a β‑reduction strategy, evaluate, and inspect the reduction
          steps.
        </p>
      </header>

      <section class="info-accordion" aria-label="About and help">
        <details>
          <summary>How to use</summary>
          <p>
            Lambda calculus is a formal system for representing computation
            created by Alonzo Church in 1930s. If you think as a programming
            language, it's turing complete.
          </p>
            <p>
              As a rewriting system, untyped lambda calculus is not strongly
              normalizing. Meaning that there are terms with no normal form such
              as: <code>(\x.x x) (\x.x x)</code>
            </p> 
          <p>
            And here you have a tool to play with the evaluation/normalization
            of lambda calculus expressions.
          </p>
          <h4>How to use</h4>
          <p>The format of your program must be:</p>
          <ul>
            <li><strong>0</strong> or <strong>n</strong> let bindings</li>
            <li><strong>1</strong> final expression to be evaluated</li>
          </ul>

          <h5>Equational referencing</h5>
          <p>
            It includes equational referencing, so instead of writing one big
            lambda expression, you can define certain expressions with names (as
            <code>let id = \x.x</code>) and reuse them anywhere.
          </p>
          <p>
            Before evaluation, the names will be expanded into their pure lambda
            expression definition.
          </p>
          <blockquote>
            <p>PS: let binding definitions can not be recursive.</p>
            e.g.: <code>let f = \x. f x</code> is not allowed.
          </blockquote>

          <h4>Beta-reduction</h4>
          <p>
            A Beta-reduction is one reduction step of an application between an
            abstraction and an expression.
          </p>
          <blockquote>
            <p>Note: a <em>redex</em> is any expression in the form
            <code>(\x.t) e</code></p>
          </blockquote>
          <p>
            <code>(\x. x y) &lt;expr&gt;</code>. Here, <code>x</code> is
            substituted for <code>&lt;expr&gt;</code> in the body of the
            abstraction. Thus <code>&lt;expr&gt; y</code>.
          </p>
          <p>
            The tool supports evaluation with three beta-reduction strategies,
            two strong and one weak.
          </p>
          <blockquote>
            <p>
              Strong reduction: it reduces under lambdas. It can reach normal
              form if it terminates.
            </p>
            <p>
              Weak reduction: it does NOT reduce under lambdas. It's still
              possible to find the normal form using weak reduction strategies
              depending on the expression (if they do not require reducing under
              lambdas). But if not, the last weak reduction results in a Weak
              Head Normal Form (WHNF).
            </p>
          </blockquote>

          <h5>Normal Order (Strong, Non-Strict):</h5>
          <p>It reduces first the <em>leftmost outermost</em> redex.</p>
          <p>
            Arguments are substituted into the abstraction body before being
            reduced.
          </p>
          <pre><code class="language-hs">let f = \a. a b c
let arg = (\x.x) y -- not in normal form, it can be reduced

f arg

-- ONE beta-reduction step outputs:

arg b c
-- or
((\x.x) y) b c
</code></pre>
          <p>
            Normal Order reduction is normalizing, meaning it's guaranteed to
            reduce until normal form if such term has a normal form.
          </p>

          <h5>Applicative (Strong, Strict):</h5>
          <p>It reduces first the <em>leftmost innermost</em> redex.</p>
          <p>Arguments are reduced first, and then substituted.</p>
          <pre><code class="language-hs">let f = \a. a b c
let arg = (\x.x) y -- not in normal form, it can be reduced

f arg

-- ONE beta-reduction step outputs:

f y
-- or
(\a. a b c) y
</code></pre>

          <h6>Applicative is not normalizing</h6>
          <p>
            Applicative does not guarantee to reduce until normal form if one
            exists.
          </p>
          <pre><code class="language-hs">let const = \x. \y. x
let omega = (\x. x x) (\x. x x)

const ok omega
</code></pre>
          <p>
            Normal order fully normalizes the expression as it does not try to
            reduce omega.
          </p>
          <p>
            Applicative does not terminate because it tries to reduce omega
            first.
          </p>

          <h5>Call-by-name (Weak, non-strict but it may recompute reductions)</h5>
          <p>
            It reduces only the leftmost outermost expression until it's a
            lambda, and then it applies the arguments without reducing them.
          </p>

          <h4>Final notes</h4>
          <ul>
            <li>It does not feature eta-reductions.</li>
            <li>
              Call-by-value (Weak, Strict) and Call-by-need (Weak, Non-Strict)
              to be implemented yet.
            </li>
          </ul>

          <h4>Learn more here:</h4>
          <ul>
            <li>
              <a href="https://en.wikipedia.org/wiki/Lambda_calculus"
                >https://en.wikipedia.org/wiki/Lambda_calculus</a
              > (wikipedia)
            </li>
            <li>
              <a href="https://serokell.io/blog/untyped-lambda-calculus"
                >https://serokell.io/blog/untyped-lambda-calculus</a
              > (serokell)
            </li>
            <li>
              <a href="https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf"
                >https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf</a
            </li>
            <li>
              <a
                href="https://www.cs.bu.edu/fac/snyder/cs320/Lectures/Lecture15--%20Lambda%20Calculus%20II.pdf"
                >https://www.cs.bu.edu/fac/snyder/cs320/Lectures/Lecture15--%20Lambda%20Calculus%20II.pdf</a
              >
            </li>
            <li>
              <a
                href="https://opendsa.cs.vt.edu/ODSA/Books/PL/html/ReductionStrategies.html"
                >https://opendsa.cs.vt.edu/ODSA/Books/PL/html/ReductionStrategies.html</a
              > (on beta reductions)
            </li>
          </ul>
        </details>
        <details>
          <summary>About λ-calculus</summary>
          <p></p>
        </details>
      </section>

      <article class="panel">
        <form
          hx-post="/eval"
          hx-target="#results"
          hx-swap="innerHTML"
          hx-disabled-elt="#evalButton"
        >
          <label>
            <input type="checkbox" name="withPrelude" />
            <span>
              Include Prelude (<a
                href="https://github.com/PedrobyJoao/untyped-lambda-evaluator/blob/main/static/prelude.lam"
                >source code</a
              >)
            </span>
          </label>

          <label for="expr" class="sr-only">Expression</label>
          <textarea id="expr" name="expr" rows="10" required>
-- Example format:
-- 1) zero or more let bindings (definitions)
-- 2) a final expression to evaluate (the last non-comment line)

-- Church numerals
let one = \f.\x. f x
let two = \f.\x. f (f x)
let three = \f.\x. f (f (f x))

let add = \m.\n.\f.\x. m f (n f x)

-- expression to be evaluated (1 + 2)
add one two
          </textarea>

          <fieldset>
            <legend>Reduction strategy:</legend>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="normal" checked />
                <span>Normal order</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="applicative" />
                <span>Applicative order</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="cbn" />
                <span>Call-by-name (WHNF)</span>
              </label>
            </div>

            <div class="strategy-row">
              <label>
                <input type="radio" name="strategy" value="cbv" />
                <span>Call-by-Value (WHNF)</span>
              </label>
            </div>
          </fieldset>

          <label>
            <input type="checkbox" name="showSteps" />
            <span>Show β-Reduction steps</span>
          </label>

          <button id="evalButton" type="submit">Evaluate</button>
        </form>
      </article>

      <!-- Hidden by default by being empty; populated after /eval -->
      <div id="results"></div>
    </main>

    <script src="https://unpkg.com/htmx.org@2.0.7"></script>
  </body>
</html>
